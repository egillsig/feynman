(* Possible additions:
   * Unit definitions, aliases, etc. 
   * Floating point/rational numbers
   * literals for tuples, lists, vectors ...
   * type classes *)

program         : statement (<';;'> statement)* <';;'>?

<statement>     : <'def'> definition | tl-expression

<definition>    : def | func-def
def             : name (<':'> type-expr)? <'='> tl-expression
func-def        : name <'['> arg-list <']'> (<':'> type-expr)? <'='> tl-expression

(* Is this all we want to be able to express in type expressions? *)
type-expr       : name
                | type-expr '*' type-expr
                | type-expr '/' type-expr
                | type-expr '^' number

arg-list        : arg-name (<','> arg-name)* | epsilon
<arg-name>      : name (<':'> type-expr)?

<tl-expression> : function | if | let | expr

function        : <'fn'> <'['> arg-list <']'> tl-expression
if              : <'if'> tl-expression <'then'> tl-expression <'else'> tl-expression

(* let definitions should be identical to other definitions, this calls for
   change in inference mechanism *)
let             : <'let'> name <'='> tl-expression <'in'> tl-expression

expr            : a_expr (logic-op a_expr)?
logic-op        : '<' | '>' | '<=' | '>=' | '==' | '!=' | '&' | '|'

a_expr          : m_expr | a_expr a_op m_expr
a_op            : '+' | '-'

m_expr          : first_u_expr | m_expr m_op u_expr
m_op            : '*' | '/' | epsilon

(* Unary +/- operators can only appear as the first term in an m_expr *)
first_u_expr    : ('+' | '-')? u_expr
u_expr          : power | '!' u_expr

(* The power operator will not be bossible to type, should remove *)
power           : primary ('^' first_u_expr)?

primary         : name | number | boolean | apply | <'('> tl-expression <')'> 

apply           : primary <'['> argument-list <']'>
argument-list : (expr (<','> argument-list)*)?

name            : !keyword #'[a-zA-Z_][a-zA-Z0-9_]*'
number          : #'\d+'
boolean         : 'True' | 'False'
keyword         : 'def' | 'fn' | 'if' | 'then' | 'else' | 'let' | 'in'
